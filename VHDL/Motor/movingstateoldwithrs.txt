-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2013 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Altera Program License
-- Subscription Agreement, Altera MegaCore Function License
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of
-- programming logic devices manufactured by Altera and sold by
-- Altera or its authorized distributors.  Please refer to the
-- applicable agreement for further details.


-- Generated by Quartus II 64-Bit Version 13.0 (Build Build 232 06/12/2013)
-- Created on Sun Nov 22 11:59:40 2015

LIBRARY ieee;
use ieee.numeric_std.all;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;


--  Entity Declaration

ENTITY movingStates IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
	clk : IN STD_LOGIC;
	rst : IN STD_LOGIC;
	rs_data : IN STD_LOGIC_VECTOR(7 downto 0);
	echo_count0 : IN std_logic_vector(20 downto 0);
	echo_count1 : IN std_logic_vector(20 downto 0);
	echo_count2 : IN std_logic_vector(20 downto 0);
	echo_count3 : IN std_logic_vector(20 downto 0);
	stop_bit_in : IN std_logic;
	strike_confirm : out std_logic;
	pwm0_s : OUT STD_LOGIC_VECTOR(13 downto 0);
	pwm1_s : OUT STD_LOGIC_VECTOR(13 downto 0);
	pwm2_s : OUT STD_LOGIC_VECTOR(13 downto 0);
	pwm3_s : OUT STD_LOGIC_VECTOR(13 downto 0);
	ostate : OUT STD_LOGIC_VECTOR(6 downto 0);
	direction0_s : OUT STD_LOGIC_VECTOR(1 downto 0);
	direction1_s : OUT STD_LOGIC_VECTOR(1 downto 0);
	direction2_s : OUT STD_LOGIC_VECTOR(1 downto 0);
	direction3_s : OUT STD_LOGIC_VECTOR(1 downto 0);
	ready_out : OUT STD_LOGIC
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END movingStates;


--  Architecture Body

ARCHITECTURE movingStates_architecture OF movingStates IS

type state_type is (start,drivingDistance,align,alignedDriving,delayAlign,delayAlignedDriving,moveUntil,afterMoveUntil,delayMoveUntil,rotate90,delayRotate90,
rs_start,rs_stop,rs_move,rs_rotate,rs_strike,rs_ready);

signal current_state,next_state,save_state: state_type;

signal drivingDistance_condition_far,drivingDistance_condition_close,drivingDistance_condition,
align_bigright,align_bigleft,align_delta_right,align_delta_left,alignedDriving_condition,moveUntil_condition,
rotate90_condition,rs_right_condition,rs_left_condition,rs_forward_condition,rs_backward_condition,
rs_clockwise_condition,rs_cClockwise_condition,rs_move_condition,rs_rotate_condition,rs_delay_condition,
rs_reset_condition,strike_stop_condition,rs_strike_condition,rs_ready_condition : boolean;
signal delay_active : boolean;
signal delay_condition : boolean;
signal afterMoveUntil_active : boolean;
signal afterMoveUntil_condition : boolean;
signal rs_delay : boolean;
signal rs_active : boolean;

signal rs_data_old : std_logic_vector(7 downto 0);
signal rs_counter : std_logic_vector(16 downto 0);
signal delta : std_logic_vector(20 downto 0);
--signal speed_delta_align : std_logic_vector(13 downto 0);
--signal speed_delta_aligned_driving : std_logic_vector(13 downto 0);
signal delay_counter : std_logic_vector(31 downto 0) := (others => '0');
signal afterMoveUntil_counter : std_logic_vector(31 downto 0) := (others => '0');
signal ready : std_logic:= '0';
signal Sstrike_confirm : std_logic := '0';
signal kaki : std_logic_vector (31 downto 0);
constant speed_0 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(0, 14));
constant speed_30 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(3750, 14));
constant speed_40 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(5000, 14));
constant speed_50 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(6250, 14));
constant speed_60 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(7500, 14));
constant speed_70 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(8750, 14));
constant speed_80 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(10000, 14));
constant speed_90 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(11250, 14));
constant speed_95 : std_LOGIC_VECTOR(13 downto 0) := std_LOGIC_VECTOR(to_unsigned(11875, 14));
constant speed_100 : std_logic_vector(13 downto 0) := std_logic_vector(to_unsigned(12500, 14));
constant direction_free : std_logic_vector(1 downto 0):= "00";
constant direction_clockWise : std_logic_vector(1 downto 0):= "01";
constant direction_cClockWise : std_logic_vector(1 downto 0):= "10";
constant direction_break : std_logic_vector(1 downto 0):= "11";


BEGIN


-- Driving Distance Conditions 
drivingDistance_condition_far <= (echo_count0 < 60000 or echo_count1 < 60000) ; 
drivingDistance_condition_close <=  (echo_count0 > 30000 or echo_count1 > 30000);
drivingDistance_condition <= (drivingDistance_condition_far AND drivingDistance_condition_close);
-- Align Conditions
align_delta_right <= ((align_bigright) AND (delta > 300));
align_delta_left <= ((align_bigleft) AND (delta > 300));
-- Aligned Driving Conditions 
alignedDriving_condition <= (echo_count0 > 90000 AND echo_count1 > 90000);
-- Move Until Conditions
moveUntil_condition <= (echo_count2 < 180000 AND echo_count3 < 180000);
-- Rotate90 Condition
rotate90_condition <= (delta < 15000 AND echo_count0 < 100000 AND echo_count1 < 100000);
rs_move_condition <= (rs_data = 2 OR rs_data = 3 OR rs_data = 6 OR rs_data = 7);
rs_rotate_condition <= (rs_data = 4 OR rs_data = 5);
rs_right_condition <= (rs_data = 2);
rs_left_condition <= (rs_data = 3);
rs_forward_condition <= (rs_data = 6);
rs_backward_condition <= (rs_data = 7);
rs_clockwise_condition <= (rs_data = 4);
rs_cClockwise_condition <= (rs_data = 5);
rs_reset_condition <= (rs_data = 0);
rs_delay_condition <= (rs_delay = true);
rs_strike_condition <= (rs_data = 10);
rs_ready_condition <= (rs_data = 9);
strike_stop_condition <= (stop_bit_in = '1');
ready_out <= ready;
--strike_confirm <= Sstrike_confirm;
rs_data_old <= rs_data;

process(echo_count0,echo_count1,delta)
begin 
	if(echo_count1 < echo_count0) then
		align_bigright <= true;
		align_bigleft <= false;
		delta <= echo_count0 - echo_count1;
	else 
		align_bigright <= false;
		align_bigleft <= true;
		delta <= echo_count1 - echo_count0;
	end if;
	--speed_delta_align <= speed_40 - delta(13 downto 0);
	--speed_delta_aligned_driving <= speed_100 - delta(13 downto 0);
end process;


process(rst,clk) 
BEGIN
	if rst = '1' then
		current_state <= start;
	elsif clk = '1' and clk'event then
		current_state <= next_state;
	end if;
end process;

process(rst,clk) 
BEGIN
	if rst = '1' then
		delay_counter <= (others => '0');
		rs_counter <= (others => '0');
		rs_delay <= false;
	elsif clk = '1' and clk'event then
		if	(delay_active) then
			if (delay_counter < 50000000) then
				delay_counter <= delay_counter + '1';
				delay_condition <= false;
			else
				delay_counter <= (others => '0');
				delay_condition <= true;
			end if;
		else
			delay_counter <= (others => '0');
			delay_condition <= false;
		end if;
		if(rs_counter > 10000000) then
			rs_delay <= not rs_delay;
			rs_counter <= (others => '0');
		else
			rs_counter <= rs_counter + '1';
		end if;
		
	end if;	
end process;

process(rst,clk) 
BEGIN
	if rst = '1' then
		afterMoveUntil_counter <= (others => '0');
	elsif clk = '1' and clk'event then
		if	(afterMoveUntil_active) then
			if (afterMoveUntil_counter < 30000000) then
				afterMoveUntil_counter <= afterMoveUntil_counter + '1';
				afterMoveUntil_condition <= false;
			else
				afterMoveUntil_counter <= (others => '0');
				afterMoveUntil_condition <= true;
			end if;
		else
			afterMoveUntil_counter <= (others => '0');
			afterMoveUntil_condition <= false;
		end if;
	end if;	
end process;

process(current_state,next_state,drivingDistance_condition,drivingDistance_condition_far,drivingDistance_condition_close,
align_delta_right,align_delta_left,alignedDriving_condition,delay_condition,afterMoveUntil_condition,
rs_right_condition,rs_left_condition,rs_forward_condition,rs_backward_condition,
rs_move_condition,rs_rotate_condition,strike_stop_condition,
rs_strike_condition,rs_ready_condition,moveUntil_condition,rotate90_condition,rs_reset_condition,
rs_delay_condition,rs_clockwise_condition,rs_cClockwise_condition,Sstrike_confirm)
begin
	next_state <= current_state;
	case current_state is
		when start =>
			pwm0_s <= speed_0;
			pwm1_s <= speed_0;
			pwm2_s <= speed_0;
			pwm3_s <= speed_0;
			direction0_s <= direction_free;
			direction1_s <= direction_free;
			direction2_s <= direction_free;
			direction3_s <= direction_free;
			delay_active <= false;
			next_state <= drivingDistance;
			ready <= '0';
		when drivingDistance=>
			if(drivingDistance_condition) then
				next_state <= align;
			elsif(drivingDistance_condition_far) then
				pwm0_s <= speed_100;
				pwm1_s <= speed_0;
				pwm2_s <= speed_100;
				pwm3_s <= speed_0;
				direction0_s <= direction_cClockWise;
				direction1_s <= direction_free;
				direction2_s <= direction_clockWise;
				direction3_s <= direction_free;
			elsif(drivingDistance_condition_close) then
				pwm0_s <= speed_100;
				pwm1_s <= speed_0;
				pwm2_s <= speed_100;
				pwm3_s <= speed_0;
				direction0_s <= direction_clockWise;
				direction1_s <= direction_free;
				direction2_s <= direction_cClockWise;
				direction3_s <= direction_free;
			end if;
			
		when align =>
			if(align_delta_right) then
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_40;
				direction0_s <= direction_free;
				direction1_s <= direction_free;
				direction2_s <= direction_free;
				direction3_s <= direction_clockWise;
			elsif(align_delta_left) then
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_40;
				direction0_s <= direction_free;
				direction1_s <= direction_free;
				direction2_s <= direction_free;
				direction3_s <= direction_cClockWise;
			else
				next_state <= delayAlign;
			end if;
			
		when delayAlign => 
			delay_active <= true;
			if delay_condition then
				delay_active <= false;
				next_state <= alignedDriving;
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_0;
				direction0_s <= direction_break;
				direction1_s <= direction_break;
				direction2_s <= direction_break;
				direction3_s <= direction_break;
			end if;
			
		when alignedDriving =>
			if alignedDriving_condition then 
				next_state <= delayAlignedDriving;
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_100;
				pwm2_s <= speed_0;
				pwm3_s <= speed_100;
				direction0_s <= direction_free;
				direction1_s <= direction_cClockWise;
				direction2_s <= direction_free;
				direction3_s <= direction_clockWise;
			end if;
			
		when delayAlignedDriving =>
			delay_active <= true;
			if delay_condition then
				delay_active <= false;
				next_state <= moveUntil;
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_0;
				direction0_s <= direction_break;
				direction1_s <= direction_break;
				direction2_s <= direction_break;
				direction3_s <= direction_break;
			end if;
		
		when moveUntil =>
			if moveUntil_condition then 
				next_state <= afterMoveUntil;
			else
				pwm0_s <= speed_100;
				pwm1_s <= speed_0;
				pwm2_s <= speed_100;
				pwm3_s <= speed_0;
				direction0_s <= direction_clockWise;
				direction1_s <= direction_free;
				direction2_s <= direction_cClockWise;
				direction3_s <= direction_free;
			 end if;
		
		when afterMoveUntil => 
			afterMoveUntil_active <= true;
			if afterMoveUntil_condition then
				afterMoveUntil_active <= false;
				next_state <= delayMoveUntil;
			else
				pwm0_s <= speed_100;
				pwm1_s <= speed_0;
				pwm2_s <= speed_100;
				pwm3_s <= speed_0;
				direction0_s <= direction_clockWise;
				direction1_s <= direction_free;
				direction2_s <= direction_cClockWise;
				direction3_s <= direction_free;
			end if;
			
				
		when delayMoveUntil =>
			delay_active <= true;
			if delay_condition then
				delay_active <= false;
				next_state <= rotate90;
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_0;
				direction0_s <= direction_break;
				direction1_s <= direction_break;
				direction2_s <= direction_break;
				direction3_s <= direction_break;
			end if;
		
		when rotate90 =>
			 if rotate90_condition then
				 next_state <= delayRotate90;
			else 
				 pwm0_s <= speed_0;
				 pwm1_s <= speed_80;
				 pwm2_s <= speed_0;
				 pwm3_s <= speed_80;
				 direction0_s <= direction_free;
				 direction1_s <= direction_clockWise;
				 direction2_s <= direction_free;
				 direction3_s <= direction_clockWise;
			 end if;
			
		when delayRotate90 =>
			delay_active <= true;
			if delay_condition then
				delay_active <= false;
				next_state <= start;
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_0;
				direction0_s <= direction_break;
				direction1_s <= direction_break;
				direction2_s <= direction_break;
				direction3_s <= direction_break;
			end if;
			
		when rs_start =>
			next_state <= rs_stop;
		
		when rs_stop =>
			if (rs_move_condition) then
				next_state <= rs_move; -- rs_move
			elsif(rs_rotate_condition) then
				next_state <= rs_rotate; -- rs_rotate
			elsif(rs_reset_condition) then
				next_state <= start; --start
			elsif (rs_strike_condition) then
				next_state <= rs_strike;
			elsif (rs_ready_condition) then
				next_state <= rs_ready; -- rs_ready
			else
				pwm0_s <= speed_0;
				pwm1_s <= speed_0;
				pwm2_s <= speed_0;
				pwm3_s <= speed_0;
				direction0_s <= direction_break;
				direction1_s <= direction_break;
				direction2_s <= direction_break;
				direction3_s <= direction_break;
			end if;
			
		when rs_move =>
			if(rs_right_condition) then 
				if(rs_delay_condition) then
					pwm0_s <= speed_0;
					pwm1_s <= speed_80;
					pwm2_s <= speed_0;
					pwm3_s <= speed_80;
					direction0_s <= direction_break;
					direction1_s <= direction_cClockWise;
					direction2_s <= direction_break;
					direction3_s <= direction_clockWise;
				end if;
			elsif(rs_left_condition) then 
				if(rs_delay_condition) then
					pwm0_s <= speed_0;
					pwm1_s <= speed_80;
					pwm2_s <= speed_0;
					pwm3_s <= speed_80;
					direction0_s <= direction_break;
					direction1_s <= direction_clockWise;
					direction2_s <= direction_break;
					direction3_s <= direction_cClockWise;
				end if;
			elsif(rs_forward_condition) then 
				if(rs_delay_condition) then
					pwm0_s <= speed_100;
					pwm1_s <= speed_0;
					pwm2_s <= speed_100;
					pwm3_s <= speed_0;
					direction0_s <= direction_cClockWise;
					direction1_s <= direction_free;
					direction2_s <= direction_clockWise;
					direction3_s <= direction_free;
				end if;
			elsif(rs_backward_condition) then 
				if(rs_delay_condition) then
					pwm0_s <= speed_100;
					pwm1_s <= speed_0;
					pwm2_s <= speed_100;
					pwm3_s <= speed_0;
					direction0_s <= direction_clockWise;
					direction1_s <= direction_free;
					direction2_s <= direction_cClockWise;
					direction3_s <= direction_free;
				end if;
			else
				next_state <= rs_stop;
			end if;
			
		when rs_rotate =>
			if(rs_clockwise_condition) then
				if(rs_delay_condition) then
					pwm0_s <= speed_0;
					pwm1_s <= speed_90;
					pwm2_s <= speed_0;
					pwm3_s <= speed_90;
					direction0_s <= direction_break;
					direction1_s <= direction_cClockWise;
					direction2_s <= direction_break;
					direction3_s <= direction_cClockWise;
				end if;
			elsif(rs_cClockwise_condition) then
				if(rs_delay_condition) then
					pwm0_s <= speed_0;
					pwm1_s <= speed_95;
					pwm2_s <= speed_0;
					pwm3_s <= speed_95;
					direction0_s <= direction_break;
					direction1_s <= direction_clockWise;
					direction2_s <= direction_break;
					direction3_s <= direction_clockWise;
				end if;
			else
				next_state <= rs_stop;
			end if;
		
		when rs_strike => 
			strike_confirm <= '1';
			if strike_stop_condition then 
				strike_confirm <= '0';
				next_state <= rs_stop;
			else
				strike_confirm <= Sstrike_confirm;
			end if;
			
		when rs_ready =>
			if(rs_ready_condition) then
					pwm0_s <= speed_0;
					pwm1_s <= speed_0;
					pwm2_s <= speed_0;
					pwm3_s <= speed_0;
					direction0_s <= direction_break;
					direction1_s <= direction_break;
					direction2_s <= direction_break;
					direction3_s <= direction_break;
					ready <= '1';
			else
			   ready <= '0';
				next_state <= rs_stop;
			end if;	