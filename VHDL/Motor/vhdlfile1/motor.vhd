-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2013 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Altera Program License
-- Subscription Agreement, Altera MegaCore Function License
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of
-- programming logic devices manufactured by Altera and sold by
-- Altera or its authorized distributors.  Please refer to the
-- applicable agreement for further details.


-- Generated by Quartus II 64-Bit Version 13.0 (Build Build 232 06/12/2013)
-- Created on Mon Nov 09 17:40:37 2015

LIBRARY ieee;
use ieee.numeric_std.all;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;


--  Entity Declaration

ENTITY motor IS
	PORT
	(
		gclk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		--ZedBoard 
		zynq_input : IN std_LOGIC_VECTOR(2 downto 0);
		-- ECHO
		echo0 : IN STD_LOGIC;
		echo1 : IN STD_LOGIC;
		echo2 : IN STD_LOGIC;
		echo3 : IN STD_LOGIC;
		-- TOGGLE
		switch0 : IN STD_LOGIC;
		switch1 : IN STD_LOGIC;
		switch2 : IN STD_LOGIC;
		switch3 : IN STD_LOGIC;
		toggle_await : IN STD_LOGIC;
		-- RS232
		RXD_in : IN STD_LOGIC;
		TXD : OUT STD_LOGIC; 
		TXD_computer : out std_logic;
		DataLoad : OUT  STD_LOGIC;
		topOstate   :OUT  std_logic_vector(7 downto 0);
		DI : in std_logic;
		EN : in std_logic;
		send : in std_logic;
		COM : in std_logic;
		-- MOTOR
		pwm0 : OUT STD_LOGIC;
		pwm1 : OUT STD_LOGIC;
		pwm2 : OUT STD_LOGIC;
		pwm3 : OUT STD_LOGIC;
		direction0 : OUT STD_LOGIC;
		direction1 : OUT STD_LOGIC;
		direction2 : OUT STD_LOGIC;
		direction3 : OUT STD_LOGIC;
		trigger0 : OUT STD_LOGIC;
		trigger1 : OUT STD_LOGIC;
		trigger2 : OUT STD_LOGIC;
		trigger3 : OUT STD_LOGIC;
		state_out : OUT  STD_LOGIC_VECTOR(6 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END motor;


--  Architecture Body

ARCHITECTURE motor_architecture OF motor IS

--                     TYPES

--                     SIGNALS
signal trigger_enable0 : std_logic:='0';
signal trigger_enable1 : std_logic:='0';
signal trigger_enable2 : std_logic:='0';
signal trigger_enable3 : std_logic:='0';
signal echo_output0 : std_logic_vector(20 downto 0);
signal echo_output1 : std_logic_vector(20 downto 0);
signal echo_output2 : std_logic_vector(20 downto 0);
signal echo_output3 : std_logic_vector(20 downto 0);
signal motor_pwm0: STD_LOGIC_VECTOR(15 downto 0):=(others => '0');
signal motor_pwm1: STD_LOGIC_VECTOR(15 downto 0):=(others => '0');
signal motor_pwm2: STD_LOGIC_VECTOR(15 downto 0):=(others => '0');
signal motor_pwm3: STD_LOGIC_VECTOR(15 downto 0):=(others => '0');
signal delta : std_logic_vector(19 downto 0);
signal biggerSonar_Front : std_logic :='0'; --0 = e2 is bigger, 1 = e3 is bigger
signal rs_data : std_LOGIC_VECTOR(7 downto 0);
signal rs_count : std_LOGIC_VECTOR(3 downto 0);
signal rs_done : std_LOGIC;
signal Sstrike_confirm : std_logic;
signal Sstop_bit_out : std_logic;
signal ready : std_logic;
signal EOF_signal : std_logic;
signal sCOM_send,sCOM_send_moving : std_logic;


--                    COMPONENTS
component echo_block is
PORT
	(
		rst : IN STD_LOGIC;
		clk : IN STD_LOGIC;
		echo : IN STD_LOGIC;
		output : OUT STD_LOGIC_VECTOR (20 downto 0)
	);
end component;

component uart is
    port (  
        clock               :   in  std_logic;
        reset               :   in  std_logic;
		  ready               :   in  std_logic;
		  zynq_data           :   in  std_logic_vector(2 downto 0);		  
        data_stream_out     :   out std_logic_vector(7 downto 0);
        rx                  :   in  std_logic
    );
end component;

component PWM is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		pwm_input : IN STD_LOGIC_VECTOR(15 downto 0);
		opwm : OUT STD_LOGIC
	);
end component;

component ultra_sonar is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		enable : IN STD_LOGIC;
		trigger : OUT STD_LOGIC
	);
end component;

component trigger_mux is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		t_enable0 : OUT STD_LOGIC;
		t_enable1 : OUT STD_LOGIC;
		t_enable2 : OUT STD_LOGIC;
		t_enable3 : OUT STD_LOGIC
	);
end component;

component movingStates is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		echo_count0 : IN std_logic_vector(20 downto 0);
		echo_count1 : IN std_logic_vector(20 downto 0);
		echo_count2 : IN std_logic_vector(20 downto 0);
		echo_count3 : IN std_logic_vector(20 downto 0);
		rs_data : IN STD_LOGIC_VECTOR(7 downto 0);
		toggle_await : IN std_logic;
		EOF_flag : in std_logic;
		strike_confirm : OUT std_logic;
		pwm0_s : OUT STD_LOGIC_VECTOR(15 downto 0);
		pwm1_s : OUT STD_LOGIC_VECTOR(15 downto 0);
		pwm2_s : OUT STD_LOGIC_VECTOR(15 downto 0);
		pwm3_s : OUT STD_LOGIC_VECTOR(15 downto 0);
		direction0_s : OUT STD_LOGIC;
		direction1_s : OUT STD_LOGIC;
		direction2_s : OUT STD_LOGIC;
		direction3_s : OUT STD_LOGIC;
		COM_send : OUT STD_LOGIC;
		ready_out : OUT STD_LOGIC;
		ostate : OUT  STD_LOGIC_vector(6 downto 0)
	);
end component;

component top is 
	Port(
		gclk     : in std_logic;
      rst      : in std_logic;
		strike_confirm : in std_logic;
		input_DI : in std_logic;
		input_EN : in std_logic;
		input_COM : in std_logic;
		input_send : in std_logic;
		DataLoad : out std_logic;	
		TXD      : out std_logic;
		TXD_computer : out std_logic;
		EOF_data : out  std_logic;
		topOstate   :out  std_logic_vector(7 downto 0)
		);
end component;
	
component RecieveLogic1 is 
	   PORT (
			clk            : in  std_logic;
         rst            : in  std_logic;
			ready          : in  std_logic;
         RXD            : in  std_logic;
			zynq_input : IN STD_LOGIC_VECTOR(2 downto 0);
         REdata         : out std_logic_vector(7 downto 0);
         counterREcieve : out std_logic_vector(3 downto 0);
         done           : out std_logic
         );
end component;

component COM_rs232 is 
	PORT (
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		COM_input : IN STD_LOGIC;
		COM_send : IN STD_LOGIC;
		COM_output : OUT STD_LOGIC
		);
end component;
--                     BEGIN OF ARCHITECTURE
BEGIN

--							  CONSTANTS

--process(gclk,rst)
--	begin
--	if (sCOM_send_moving = '1') OR (COM = '1') then 
--		sCOM_send <= '1';
--	else 
--		sCOM_send <= '0';
--	end if;
--end process;

--

Utrigger_mux: trigger_mux
port map(
	clk=>gclk,
	rst => rst,
	t_enable0=>trigger_enable0,
	t_enable1=>trigger_enable1,
	t_enable2=>trigger_enable2,
	t_enable3=>trigger_enable3
);

Uecho0: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo0,
	output=>echo_output0
);

Uecho1 : echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo1,
	output=>echo_output1
);

Uecho2: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo2,
	output=>echo_output2
);

Uecho3: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo3,
	output=>echo_output3
);

Upwm0 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm0,
	opwm=>pwm0
);

Upwm1 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm1,
	opwm => pwm1
);

Upwm2 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm2,
	opwm=>pwm2
);

Upwm3 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm3,
	opwm=>pwm3
);



Utrigger0 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable0,
	trigger => trigger0
);

Utrigger1 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable1,
	trigger => trigger1
);

Utrigger2 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable2,
	trigger => trigger2
);

Utrigger3 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable3,
	trigger => trigger3
);

UmovingStates : movingStates
port map(
	clk => gclk,
	rst => rst,
	echo_count0 => echo_output0,
	echo_count1 => echo_output1,
	echo_count2 => echo_output2,
	echo_count3 => echo_output3,
	rs_data => rs_data,
	toggle_await => toggle_await,
	strike_confirm => Sstrike_confirm,
	EOF_flag => EOF_signal,
	pwm0_s => motor_pwm0,
	pwm1_s => motor_pwm1,
	pwm2_s => motor_pwm2,
	pwm3_s => motor_pwm3,
	direction0_s => direction0,
	direction1_s => direction1,
	direction2_s => direction2,
	direction3_s => direction3,
	COM_send => sCOM_send_moving,
	ready_out => ready,
	ostate => state_out
);

unitUArt : uart
port map(
	clock => gclk,
	reset => rst,
	ready => ready,
	zynq_data => zynq_input,
	rx => RXD_in,
	data_stream_out => rs_data
);
Utop : top 
port map(
	gclk     => gclk,
   rst      => rst,
	strike_confirm => Sstrike_confirm,
	input_DI => DI,
	input_EN => EN,
	input_send => send,
	input_COM => sCOM_send,
	EOF_data => EOF_signal,
	DataLoad => DataLoad,
	TXD      => TXD,
	TXD_computer => TXD_computer,
	topOstate => topOstate
);

UCOM_rs232 : COM_rs232
port map(
		clk => gclk,
		rst => rst,
		COM_input => COM, 
		COM_send => sCOM_send_moving,
		COM_output => sCOM_send
	);

--enable0 <= switch0;
--enable1 <= switch1;
--enable2 <= switch2;
--enable3 <= switch3;

-- LOGIC


END motor_architecture;
