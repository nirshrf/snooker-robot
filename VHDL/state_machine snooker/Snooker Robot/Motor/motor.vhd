-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2013 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Altera Program License
-- Subscription Agreement, Altera MegaCore Function License
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of
-- programming logic devices manufactured by Altera and sold by
-- Altera or its authorized distributors.  Please refer to the
-- applicable agreement for further details.


-- Generated by Quartus II 64-Bit Version 13.0 (Build Build 232 06/12/2013)
-- Created on Mon Nov 09 17:40:37 2015

LIBRARY ieee;
use ieee.numeric_std.all;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;


--  Entity Declaration

ENTITY motor IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		gclk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		-- ECHO
		echo0 : IN STD_LOGIC;
		echo1 : IN STD_LOGIC;
		echo2 : IN STD_LOGIC;
		echo3 : IN STD_LOGIC;
		-- TOGGLE
		switch0 : IN STD_LOGIC;
		switch1 : IN STD_LOGIC;
		switch2 : IN STD_LOGIC;
		switch3 : IN STD_LOGIC;
		-- RS232
		RXD_in : IN std_LOGIC;
		-- MOTOR
		pwm0 : OUT STD_LOGIC;
		pwm1 : OUT STD_LOGIC;
		pwm2 : OUT STD_LOGIC;
		pwm3 : OUT STD_LOGIC;
		direction0 : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction1 : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction2 : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction3 : OUT STD_LOGIC_VECTOR(1 downto 0);
		enable0 : OUT STD_LOGIC;
		enable1 : OUT STD_LOGIC;
		enable2 : OUT STD_LOGIC;
		enable3 : OUT STD_LOGIC;
		trigger0 : OUT STD_LOGIC;
		trigger1 : OUT STD_LOGIC;
		trigger2 : OUT STD_LOGIC;
		trigger3 : OUT STD_LOGIC;
		state_out : OUT  STD_LOGIC_VECTOR(6 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END motor;


--  Architecture Body

ARCHITECTURE motor_architecture OF motor IS

--                     TYPES

--                     SIGNALS
signal trigger_enable0 : std_logic:='0';
signal trigger_enable1 : std_logic:='0';
signal trigger_enable2 : std_logic:='0';
signal trigger_enable3 : std_logic:='0';
signal echo_output0 : std_logic_vector(20 downto 0);
signal echo_output1 : std_logic_vector(20 downto 0);
signal echo_output2 : std_logic_vector(20 downto 0);
signal echo_output3 : std_logic_vector(20 downto 0);
signal motor_pwm0: STD_LOGIC_VECTOR(13 downto 0):=(others => '0');
signal motor_pwm1: STD_LOGIC_VECTOR(13 downto 0):=(others => '0');
signal motor_pwm2: STD_LOGIC_VECTOR(13 downto 0):=(others => '0');
signal motor_pwm3: STD_LOGIC_VECTOR(13 downto 0):=(others => '0');
signal delta : std_logic_vector(19 downto 0);
signal biggerSonar_Front : std_logic :='0'; --0 = e2 is bigger, 1 = e3 is bigger
signal rs_data : std_LOGIC_VECTOR(7 downto 0);
signal rs_count : std_LOGIC_VECTOR(3 downto 0);
signal rs_done : std_LOGIC;

--							  CONSTANTS



--                     COMPONENTS
component echo_block is
PORT
	(
		rst : IN STD_LOGIC;
		clk : IN STD_LOGIC;
		echo : IN STD_LOGIC;
		output : OUT STD_LOGIC_VECTOR (20 downto 0)
	);
end component;

component PWM is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		pwm_input : IN STD_LOGIC_VECTOR(13 downto 0);
		opwm : OUT STD_LOGIC
	);
end component;

component ultra_sonar is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		enable : IN STD_LOGIC;
		trigger : OUT STD_LOGIC
	);
end component;

component trigger_mux is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		t_enable0 : OUT STD_LOGIC;
		t_enable1 : OUT STD_LOGIC;
		t_enable2 : OUT STD_LOGIC;
		t_enable3 : OUT STD_LOGIC
	);
end component;

component movingStates is
	PORT
	(
		clk : IN STD_LOGIC;
		rst : IN STD_LOGIC;
		echo_count0 : IN std_logic_vector(20 downto 0);
		echo_count1 : IN std_logic_vector(20 downto 0);
		echo_count2 : IN std_logic_vector(20 downto 0);
		echo_count3 : IN std_logic_vector(20 downto 0);
		rs_data : IN STD_LOGIC_VECTOR(7 downto 0);
		rs_done : IN STD_LOGIC;
		pwm0_s : OUT STD_LOGIC_VECTOR(13 downto 0);
		pwm1_s : OUT STD_LOGIC_VECTOR(13 downto 0);
		pwm2_s : OUT STD_LOGIC_VECTOR(13 downto 0);
		pwm3_s : OUT STD_LOGIC_VECTOR(13 downto 0);
		direction0_s : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction1_s : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction2_s : OUT STD_LOGIC_VECTOR(1 downto 0);
		direction3_s : OUT STD_LOGIC_VECTOR(1 downto 0);
		ostate : out  STD_LOGIC_vector(6 downto 0)
	);
end component;
	
component RecieveLogic1 is 
	   PORT (
			clk            : in  std_logic;
         rst            : in  std_logic;
         RXD            : in  std_logic;
         REdata         : out std_logic_vector(7 downto 0);
         counterREcieve : out std_logic_vector(3 downto 0);
         done           : out std_logic
         );
end component;
--                     BEGIN OF ARCHITECTURE
BEGIN

Utrigger_mux: trigger_mux
port map(
	clk=>gclk,
	rst => rst,
	t_enable0=>trigger_enable0,
	t_enable1=>trigger_enable1,
	t_enable2=>trigger_enable2,
	t_enable3=>trigger_enable3
);

Uecho0: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo0,
	output=>echo_output0
);

Uecho1 : echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo1,
	output=>echo_output1
);

Uecho2: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo2,
	output=>echo_output2
);

Uecho3: echo_block 
port map(
	clk=>gclk,
	rst => rst,
	echo=>echo3,
	output=>echo_output3
);

Upwm0 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm0,
	opwm=>pwm1
);

Upwm1 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm1,
	opwm=>pwm3
);

Upwm2 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm2,
	opwm=>pwm0
);

Upwm3 : PWM 
port map(
	clk=>gclk,
	rst => rst,
	pwm_input => motor_pwm3,
	opwm=>pwm2
);

Utrigger0 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable0,
	trigger => trigger0
);

Utrigger1 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable1,
	trigger => trigger1
);

Utrigger2 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable2,
	trigger => trigger2
);

Utrigger3 : ultra_sonar
port map(
	clk => gclk,
	rst => rst,
	enable => trigger_enable3,
	trigger => trigger3
);

UmovingStates : movingStates
port map(
	clk => gclk,
	rst => rst,
	echo_count0 => echo_output0,
	echo_count1 => echo_output1,
	echo_count2 => echo_output2,
	echo_count3 => echo_output3,
	rs_data => rs_data,
	rs_done => rs_done,
	pwm0_s => motor_pwm0,
	pwm1_s => motor_pwm1,
	pwm2_s => motor_pwm2,
	pwm3_s => motor_pwm3,
	direction0_s => direction0,
	direction1_s => direction1,
	direction2_s => direction2,
	direction3_s => direction3,
	ostate => state_out
);


enable0 <= switch0;
enable1 <= switch1;
enable2 <= switch2;
enable3 <= switch3;

-- LOGIC


END motor_architecture;
